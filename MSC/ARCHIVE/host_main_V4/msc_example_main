/*
 * SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Unlicense OR CC0-1.0
 */

 
#include "sdkconfig.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define LOG_LOCAL_LEVEL ESP_LOG_DEBUG
#include "esp_log.h"
#include "driver/uart.h"
#include "esp_err.h"

// USB MSC includes
#include "usb/usb_host.h"
#include "usb/msc_host.h"
#include "esp_private/usb_phy.h" 
#include "esp_private/msc_scsi_bot.h"   // SCSI BOT API

static const char *TAG = "msc_host_boardB";

// ---------------- UART CONFIG ----------------
#define UART_PORT_NUM      UART_NUM_1
#define UART_BAUD_RATE     115200
#define UART_TX_PIN        17
#define UART_RX_PIN        18
#define UART_BUF_SIZE      1024

static QueueHandle_t uart_queue;

//ensuring USB-OTG VBUS is set to high (5V to USB-MSC device)
//static usb_phy_handle_t phy_hdl = NULL;
// issue verified through software & hardware testing, 4.76V is being supplied.


// ---------------- USB MSC ----------------
static msc_host_device_handle_t msc_dev = NULL;

// ---------------- UART FRAME ----------------
static bool validate_checksum(uint8_t *frame, int len) {
    if (len < 4) return false;
    uint8_t type = frame[1];
    uint8_t payload_len = frame[2];
    if (len != payload_len + 4) return false;

    uint32_t sum = type + payload_len;
    for (int i = 0; i < payload_len; i++) sum += frame[3 + i];
    uint8_t expected = (uint8_t)(0x100 - (sum & 0xFF));
    return frame[len - 1] == expected;
}

// ---------------- UART RX TASK ----------------
static void uart_rx_task(void *arg) {
    uint8_t data[UART_BUF_SIZE];
    uint8_t sector[512];

    while (1) {
        int len = uart_read_bytes(UART_PORT_NUM, data, sizeof(data), pdMS_TO_TICKS(100));
        if (len > 0 && data[0] == 0xA5 && validate_checksum(data, len)) {
            ESP_LOGI(TAG, "Received frame from Board A: type=%c, payload_len=%d", data[1], data[2]);
            printf(">>> Laptop Monitor: RX from Board A [type=%c, len=%d]\n", data[1], data[2]);

            if (data[1] == 'R') {
                // READ SECTOR
                uint32_t lba = (data[3] << 24) | (data[4] << 16) | (data[5] << 8) | data[6];
                esp_err_t ret = scsi_cmd_read10(msc_dev, sector, lba, 1, sizeof(sector));
                if (ret == ESP_OK) {
                    uart_write_bytes(UART_PORT_NUM, (const char *)sector, sizeof(sector));
                    ESP_LOGI(TAG, "Sent sector to Board A: LBA=%" PRIu32 ", bytes=%d", lba, (int)sizeof(sector));
                    printf("<<< Laptop Monitor: TX to Board A [READ LBA=%" PRIu32 ", size=%d]\n", lba, (int)sizeof(sector));
                } else {
                    ESP_LOGE(TAG, "Failed to read LBA=%" PRIu32 " err=%s", lba, esp_err_to_name(ret));
                    printf("xxx Laptop Monitor: READ failed [LBA=%" PRIu32 "]\n", lba);
                }

            } else if (data[1] == 'W') {
                // WRITE SECTOR
                uint32_t lba = (data[3] << 24) | (data[4] << 16) | (data[5] << 8) | data[6];
                memcpy(sector, &data[7], sizeof(sector));
                esp_err_t ret = scsi_cmd_write10(msc_dev, sector, lba, 1, sizeof(sector));
                if (ret == ESP_OK) {
                    uint8_t ack = 0xAA;
                    uart_write_bytes(UART_PORT_NUM, (const char *)&ack, 1);
                    ESP_LOGI(TAG, "Written LBA=%" PRIu32 ", ACK sent to Board A", lba);
                    printf("<<< Laptop Monitor: TX to Board A [WRITE LBA=%" PRIu32 ", ACK sent]\n", lba);
                } else {
                    ESP_LOGE(TAG, "Failed to write LBA=%" PRIu32 " err=%s", lba, esp_err_to_name(ret));
                    printf("xxx Laptop Monitor: WRITE failed [LBA=%" PRIu32 "]\n", lba);
                }
            }

        }
    }
}

/*
// ---------------- USB MSC Event Callback ----------------
static void msc_event_cb(const msc_host_event_t *event, void *arg)
{
    switch (event->event) {
    case MSC_DEVICE_CONNECTED: {
        ESP_LOGI(TAG, "MSC device connected, address=%d", event->device.address);
        esp_err_t ret = ESP_FAIL;
        for (int retry = 0; retry < 50; retry++) { // retry ~2s
            ret = msc_host_install_device(event->device.address, &msc_dev);
            if (ret == ESP_OK) {
                ESP_LOGI(TAG, "MSC device handle installed");
                break;
            } else {
                ESP_LOGW(TAG, "Retry %d: msc_host_install_device failed: %s", retry, esp_err_to_name(ret));
                vTaskDelay(pdMS_TO_TICKS(100));
            }
        }
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to install MSC device handle after retries");
            msc_dev = NULL;
        }
        break;
    }


    case MSC_DEVICE_DISCONNECTED:
        ESP_LOGI(TAG, "MSC device disconnected");

        if (msc_dev) {
            msc_host_uninstall_device(msc_dev);
            msc_dev = NULL;
        }
        break;

    default:
        ESP_LOGW(TAG, "MSC unknown event: %d", event->event);
        break;
    }
}

static void check_vbus_status(void) {
    usb_phy_status_t status;

    esp_err_t err = usb_phy_get_phy_status(USB_PHY_TARGET_INT, &status);

    if (err == ESP_OK) {
        if (status == USB_PHY_STATUS_IN_USE) {
            ESP_LOGI(TAG, "VBUS is high");
        } else {
            ESP_LOGI(TAG, "VBUS is low");
        }
    } else {
        ESP_LOGE(TAG, "Failed to get PHY status: %s", esp_err_to_name(err));
    }
}
static void usb_task(void *args)
{
 
    // USB PHY initialisation
    usb_phy_config_t phy_config = {
        .controller = USB_PHY_CTRL_OTG,
        .target = USB_PHY_TARGET_INT,
        .otg_mode = USB_OTG_MODE_HOST,
        .otg_speed = USB_PHY_SPEED_FULL,
        .ext_io_conf = NULL,
        .otg_io_conf = NULL,
    };

    ESP_ERROR_CHECK(usb_new_phy(&phy_config, &phy_hdl));
    ESP_LOGI(TAG, "USB PHY initialized in HOST mode");

    // Install USB Host library
    usb_host_config_t host_config = {
        .skip_phy_setup = true,           // Use internal PHY
        .intr_flags = ESP_INTR_FLAG_LEVEL1
    };
    ESP_ERROR_CHECK(usb_host_install(&host_config));
    ESP_LOGI(TAG, "USB Host installed");
    
    // Install MSC host driver with proper callback
    msc_host_driver_config_t msc_cfg = {
        .create_backround_task = true,
        .task_priority = 5,
        .stack_size = 4096,
        .core_id = tskNO_AFFINITY,
        .callback = msc_event_cb,
        .callback_arg = NULL
    };

    
    ESP_ERROR_CHECK(msc_host_install(&msc_cfg));
    ESP_LOGI(TAG, "MSC Host driver installed and VBUS is enabled");
    check_vbus_status();

    vTaskDelay(pdMS_TO_TICKS(200));

    // Wait for the first MSC device
    ESP_LOGI(TAG, "Waiting for USB MSC device...");
    printf(">>> Laptop Monitor: Waiting for USB MSC device...\n");

     //Wait for MSC device enumeration
    const int max_retries = 50; //around 5s
    int retries = 0;

    while (!msc_dev && retries < max_retries) {
        ESP_LOGI(TAG, "Waiting for MSC Device...");
        vTaskDelay(pdMS_TO_TICKS(100));
        retries++;
    }

    if (!msc_dev) {
        ESP_LOGE(TAG, "No MSC device detected within timeout");
        printf("xxx Laptop Monitor: No USB MSC device detected within timeout\n");
        vTaskDelete(NULL);
        return;
    } 
    ESP_LOGI(TAG, "USB MSC device ready");
    printf(">>> Laptop Monitor: USB MSC device connected and ready\n");

    vTaskDelete(NULL);
    
        bool ready_printed = false;

    while(1) {
        if (msc_dev &&!ready_printed) {
            ESP_LOGI(TAG, "USB MSC device ready");
            printf(">>> Laptop Monitor: USB MSC device connected and ready\n");
            ready_printed = true;
        }
        vTaskDelay(pdMS_TO_TICKS(500));
    }

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(500)); // just sleep, event handling is done in background task
    }
*/

/**
 * @brief MSC driver callback
 *
 * Signal device connection/disconnection to the main task
 *
 * @param[in] event MSC event
 * @param[in] arg   MSC event data
 */

static void msc_event_cb(const msc_host_event_t *event, void *arg) {
    if (event->event == MSC_DEVICE_CONNECTED) {
        ESP_LOGI(TAG, "MSC device connected (usb_addr=%d)", event->device.address);
        esp_err_t ret = ESP_FAIL;
        for (int retry = 0; retry < 50; retry++) { // retry ~5s
            ret = msc_host_install_device(event->device.address, &msc_dev);
            if (ret == ESP_OK) {
                ESP_LOGI(TAG, "MSC device handle installed");
                break;
            } else {
                ESP_LOGW(TAG, "Retry %d: msc_host_install_device failed: %s", retry, esp_err_to_name(ret));
                vTaskDelay(pdMS_TO_TICKS(100));
            }
        }

        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Failed to install MSC device handle after retries");
            msc_dev = NULL;
        }
    } else if (event->event == MSC_DEVICE_DISCONNECTED) {
        ESP_LOGI(TAG, "MSC device disconnected");
        if (msc_dev) {
            msc_host_uninstall_device(msc_dev);
            msc_dev = NULL;
        }
    } else {
        ESP_LOGW(TAG, "MSC unknown event: %d", event->event);
    }
}


// ---------------- USB TASK ----------------
static void usb_task(void *args) {
    const usb_host_config_t host_config = {
        .intr_flags = ESP_INTR_FLAG_LEVEL1,
        .skip_phy_setup = false,
        .intr_flags = ESP_INTR_FLAG_LEVEL1
    };
    
    ESP_ERROR_CHECK(usb_host_install(&host_config));


    const msc_host_driver_config_t msc_cfg = {
        .create_backround_task = true,
        .task_priority = 5,
        .stack_size = 4096,
        .core_id = tskNO_AFFINITY,
        .callback = msc_event_cb,
        .callback_arg = NULL
    };
    ESP_ERROR_CHECK(msc_host_install(&msc_cfg));


    ESP_LOGI(TAG, "USB Host and MSC driver installed");


    // Keep USB task alive for event handling
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}


// ---------------- APP MAIN ----------------
void app_main(void) {
    ESP_LOGI(TAG, "USB MSC Host Board B starting...");
    printf(">>> Laptop Monitor: Board B USB MSC Host starting...\n");

    // UART init
    uart_config_t uart_config = {
        .baud_rate = UART_BAUD_RATE,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };
    ESP_ERROR_CHECK(uart_driver_install(UART_PORT_NUM, UART_BUF_SIZE, 0, 10, &uart_queue, 0));
    ESP_ERROR_CHECK(uart_param_config(UART_PORT_NUM, &uart_config));
    ESP_ERROR_CHECK(uart_set_pin(UART_PORT_NUM, UART_TX_PIN, UART_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

    // Start tasks
    xTaskCreate(usb_task, "usb_task", 4096, NULL, 5, NULL);
    xTaskCreate(uart_rx_task, "uart_rx_task", 4096, NULL, 5, NULL);
}
